<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="js/gauge.min.js"></script>
    <title>Tables</title>
</head>
<body>
    <style>
        input[type="number"] {
            width: 3em;
            text-align: right;
            border: none;
            background: transparent;
        }
        p {
            margin: 0;
        }
        body {
            background-color: black;
            color: #ccc;
            margin: 0;
            padding: 0;
        }
        table {
            filter: brightness(.5);
            border-spacing: 0;
            border-width: 0;
        }
        canvas {
            pointer-events: none;
        }
        .section#options{
            /* display: flex; */
            flex-wrap: wrap;
            justify-content: center;
        }
        .section#options div{
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 5px;
            padding: 10px;
            border: 1px solid gray;
        }
        .section {
            display: none;
        }
        .navbar{
            position: absolute;
            top: 0;
            left: 0;
            width: 100px;
            height: 100vh;
            border: 1px solid red;
            display: flex;
            flex-direction: column;
            align-content: start;
        }
        .spacer-75 {
            height: 75px;
        }
        .section-selection {
            height: 50px;
            text-align: center;
            width: 80px;
            margin: 5px;
            display: flex;
            align-items: center;
            border: 1px solid blue;
        }
        .section-selection > p {
            margin: auto;
        }
        div.main {
            margin-left: 100px;
        }
        div#realtime {
            width: 100%;
            border-top: 1px solid red;
            padding: 5px;
        }
        div.general {
            overflow-y: scroll;
            overflow-x: hidden;
        }
        body {
            overflow: hidden;
        }
        input.no-arrows::-webkit-outer-spin-button,
        input.no-arrows::-webkit-inner-spin-button {
            /* display: none; <- Crashes Chrome on hover */
            -webkit-appearance: none;
            margin: 0; /* <-- Apparently some margin are still there even though it's hidden */
        }

        input.no-arrows[type=number] {
            -moz-appearance:textfield; /* Firefox */
        }
    </style>
    <div class="navbar" id="navbar">
        <div class="section-selection" id="injector-section-selection"><p>Fuel</p></div>
        <div class="section-selection" id="ignition-section-selection"><p>Ignition</p></div>
        <div class="section-selection" id="options-section-selection"><p>Options</p></div>
        <div class="section-selection" id="realtime-section-selection"><p>Real-Time</p></div>
        <p>Load Tune</p>
        <input type="file" id="tune-file" />
        <button id="save-tune">Save</button>
    </div>
    <div class="main">
        <div class="general" id="general">
            <div class="section" id="boost"></div>
            <div class="section" id="injector"></div>
            <div class="section" id="ignition"></div>
            <div class="section" id="options">
                <h1 style="width: 100%;">Options</h1>
            </div>
        </div>
        <div class="section" id="realtime">
            <p>Real-Time</p>
            <div class="" id="engine-data"></div>
            <div class="" id="gauges">
                <canvas id="rpm"></canvas>
            </div>
        </div>
        <div class="section" id="experimental">
            <input type="number" name="RpmOverwrite" id="RpmOverwrite" style="width: 6em;color:white;">
            <label for="RpmOverwrite">RpmOverwrite</label><br>

            <input type="number" name="MapOverwrite" id="MapOverwrite" style="width: 6em;color:white;">
            <label for="MapOverwrite">MapOverwrite</label><br>

            <input type="checkbox" name="TuningCheatOverwrite" id="TuningCheatOverwrite">
            <label for="TuningCheatOverwrite">TuningCheatOverwrite</label>
            <br>
            <h2>
                Auto-tuner
            </h2>
            <input type="number" name="fromRPM" id="fromRPM" style="width: 6em;color:white;">
            <label for="fromRPM">From RPM</label><br>

            <input type="number" name="toRPM" id="toRPM" style="width: 6em;color:white;">
            <label for="toRPM">To RPM</label><br>

            <input type="number" name="fromMAP" id="fromMAP" style="width: 6em;color:white;">
            <label for="fromMAP">From MAP</label><br>

            <input type="number" name="toMAP" id="toMAP" style="width: 6em;color:white;">
            <label for="toMAP">To MAP</label><br>

            <input type="number" name="targetAFR" id="targetAFR" style="width: 6em;color:white;">
            <label for="targetAFR">Target AFR</label><br>

            <button id="autotune">Autotune</button>
            <script type="text/javascript">
                function sendData() {
                    if(!document.querySelector('#TuningCheatOverwrite').checked){return;}
                    const rpm = document.querySelector('#RpmOverwrite').value;
                    const map = document.querySelector('#MapOverwrite').value;
                    fetch(
                        `http://${window.location.host}/command?RpmOverwrite=${rpm}&MapOverwrite=${map}`,
                    )
                };
                document.querySelector('#MapOverwrite').addEventListener("input", sendData);
                document.querySelector('#RpmOverwrite').addEventListener("input", sendData);
                document.querySelector('#TuningCheatOverwrite').addEventListener("change", function() {
                    fetch(
                        `http://${window.location.host}/command?TuningCheatOverwrite=${this.checked ? 'true' : 'false'}`,
                    )
                });
                async function autoTune(fromRPM, toRPM, fromMAP, toMAP, targetAFR) {
                    for (let rpm = fromRPM; rpm <= toRPM; rpm += 500) {
                        for (let map = fromMAP; map <= toMAP; map += 10) {
                        let target_afr = targetAFR;
                        await fetch(
                            `http://${window.location.host}/command?TuningCheatOverwrite=true&RpmOverwrite=${rpm}&MapOverwrite=${map}`
                        ).then(() => {
                            await fetch(`http://${window.location.host}/engineData.json`)
                                .then((response) => {
                                return response.json();
                                })
                                .then((json) => {
                                    afr = json.afr;
                                    console.log(afr);
                                    const val = document.getElementById(`${rpm}-${map}-injector-table`).value * afr / target_afr;
                                    document.getElementById(`${rpm}-${map}-injector-table`).value = val;
                                    document.getElementById(`${rpm}-${map}-injector-table`).dispatchEvent(new Event('input', {bubbles:true}));
                                });
                        });
                        }
                    }

                    await fetch(
                        `http://${window.location.host}/command?TuningCheatOverwrite=false&RpmOverwrite=0&MapOverwrite=0`
                    )
                }
                document.getElementById('autotune').addEventListener('click', () => {
                    autoTune(
                        Number(document.getElementById('fromRPM').value),
                        Number(document.getElementById('toRPM').value),
                        Number(document.getElementById('fromMAP').value),
                        Number(document.getElementById('toMAP').value),
                        Number(document.getElementById('targetAFR').value),
                    );
                })

            </script>
        </div>
    </div>
    <a id="downloadAnchorElem" style="display:none"></a>
    <div id="selection-editor-dialog" style="border: 1px solid red; border-radius: 10px; position: absolute; width: 50%; height: 500px; display: none; left: 50%; top: 50%; transform: translate(-50%, -50%); background: black;">
        <input type="number" id="selection-editor-dialog-modifier" style="color:white; width: 6em;" />
        <label for="selection-editor-dialog-modifier">%</label>
        <button id="selection-editor-dialog-remove">-</button>
        <button id="selection-editor-dialog-add">+</button>
        <button id="selection-editor-dialog-close">Close</button>
    </div>
    <script type="text/javascript">
        const openPanels = {};
        const sections = document.getElementsByClassName('section');
        for (const section of sections) {
            section.style.display = 'none';
        }

        const sectionSelections = document.getElementsByClassName('section-selection');
        for (const sectionSelector of sectionSelections) {
            sectionSelector.addEventListener('click', (event) => {
                console.log(event.target.id.split("-")[0]);
                const sect = document.getElementById(event.target.id.split("-")[0]);
                if(!sect){
                    return;
                }
                console.log(sect.style.display );
                if(sect.style.display === 'none'){
                    sect.style.display = 'block';
                    event.target.style.backgroundColor = '#0000ffa7';
                    openPanels[event.target.id.split("-")[0]] = true;
                }else{
                    sect.style.display = 'none';
                    event.target.style.backgroundColor = '#00000000';
                    openPanels[event.target.id.split("-")[0]] = undefined;
                }
                if (openPanels['realtime'] !== undefined){
                    document.getElementById('general').style.height = '60vh';
                }else{
                    document.getElementById('general').style.height = '100vh';
                }
            })
        }

        let tuneValues = {};
        const SUPPORTED_TUNE_VERSIONS = [0.21];
        const defaults = {
            xValues: [400, 500, 600, 700, 800, 1000, 1200, 1500, 1800, 2000, 2200, 2400, 2600, 2800, 3100, 3400, 3700, 4000, 4300, 4700, 5100, 5500, 5900, 6200, 6700, 7200, 7700, 8200, 8700, 9200].sort((a, b) => a - b),
            yValues: [100, 93, 86, 79, 72, 65, 58, 51, 44, 37, 30, 23, 16, 9, 2].sort((a, b) => b - a),
        };
        let tableToMultiselect = undefined;
        let selectedElements = [];

        document.getElementById("selection-editor-dialog-close").addEventListener("click", (event) => {
            document.getElementById("selection-editor-dialog-modifier").value = "";
            document.getElementById("selection-editor-dialog").style.display = "none";
            for (const elem of selectedElements) {
                elem.style.backgroundColor = 'transparent';
            }
            selectedElements = [];
        });
        document.getElementById("selection-editor-dialog-add").addEventListener("click", (event) => {
            const mult = document.getElementById("selection-editor-dialog-modifier").value / 100;
            console.log(document.getElementById("selection-editor-dialog-modifier").value);
            for (const elem of selectedElements) {
                elem.value = Math.round((Number(elem.value) + (Number(elem.value) * mult)) * 100) / 100;
                elem.dispatchEvent(new Event('input', {bubbles:true}));
            }
            event.preventDefault();
        });
        document.getElementById("selection-editor-dialog-remove").addEventListener("click", (event) => {
            const mult = document.getElementById("selection-editor-dialog-modifier").value / 100;
            for (const elem of selectedElements) {
                elem.value = Math.round((Number(elem.value) - (Number(elem.value) * mult)) * 100) / 100;
                elem.dispatchEvent(new Event('input', {bubbles:true}));
            }
            event.preventDefault();
        });

        const showSelectionEditorDialog = () => {
            document.getElementById("selection-editor-dialog").style.display = "block";
        }

        const addOption = (displayName, unit, sectionName, optionName, optionType, step, minimum, maximum, redValue) => {
            if (tuneValues.options === undefined){
                tuneValues.options = {};
            }
            tuneValues.options[optionName] = {
                value: 0,
                unit,
                displayName,
                sectionName,
                optionType,
                step,
                minimum,
                maximum,
                redValue
            };
        }

        const addOptionValue = (optionName, val) => {
            const value = val;

            if(tuneValues.options[optionName] === undefined){
                throw new Error();
            }

            tuneValues.options[optionName].value = value;
        }

        const getOptionValue = (optionName) => {

            if(tuneValues.options[optionName].value === undefined){
                return undefined;
            }

            return tuneValues.options[optionName].value
        }

        const addMap2D = (displayName, unit, sectionName, mapName, xName, xMin, xMax, xStep, cellsMin, cellsMax, cellsRedValue) => {
            tuneValues[mapName] = {
                type: "2D",
                values: {},
                displayName,
                unit,
                sectionName,
                xName,
                xMin,
                xMax,
                xStep,
                cellsMin,
                cellsMax,
                cellsRedValue
            }
        }

        const addMapValue2D = (mapName, col, val) => {
            const colIndex = Number(col);
            const value    = Number(val);

            if(tuneValues[mapName] === undefined){
                throw new Error();
            }

            if(tuneValues[mapName].values === undefined){
                tuneValues[mapName].values = {};
            }

            tuneValues[mapName].values[colIndex] = val;
        }

        const getMapValue2D = (mapName, col) => {
            const colIndex = Number(col);
            const rowIndex = Number(row);

            if(tuneValues[mapName].values === undefined || tuneValues[mapName].type !== "2D"){
                return undefined;
            }

            if(tuneValues[mapName].values[colIndex] === undefined){
                return undefined;
            }

            return tuneValues[mapName].values[colIndex];
        }

        const addMap3D = (displayName, unit, sectionName, mapName, xName, xValues, yName, yValues, cellsMin, cellsMax, cellsRedValue) => {
            tuneValues[mapName] = {
                type: "3D",
                values: {},
                displayName,
                unit,
                sectionName,
                xName,
                xValues: xValues,
                yName,
                yValues: yValues,
                cellsMin,
                cellsMax,
                cellsRedValue
            }
        }

        const addMapValue3D = (mapName, col, row, val) => {
            const colIndex = Number(col);
            const rowIndex = Number(row);
            const value    = Number(val);

            if(tuneValues[mapName] === undefined){
                throw new Error();
            }

            if(tuneValues[mapName].values === undefined){
                tuneValues[mapName].values = {};
            }

            if(tuneValues[mapName].values[colIndex] === undefined){
                tuneValues[mapName].values[colIndex] = {};
            }

            tuneValues[mapName].values[colIndex][rowIndex] = value;
        }

        const getMapValue3D = (mapName, col, row) => {
            const colIndex = Number(col);
            const rowIndex = Number(row);

            if(tuneValues[mapName].values === undefined || tuneValues[mapName].type !== "3D"){
                return undefined;
            }

            if(tuneValues[mapName].values[colIndex] === undefined){
                return undefined;
            }

            return tuneValues[mapName].values[colIndex][rowIndex];
        }
    
        const getCellColor = (value, redValue) => {
            const RED_VALUE = redValue;
            if(value >= RED_VALUE){
                return `hsl(0,100%,50%)`
            }

            const normalizedValue = value / RED_VALUE;
            const hue = ((1 - normalizedValue) * 120).toString(10);
            return `hsl(${hue},100%,50%)`;
        }

        const createOption = (displayName, unit, sectionName, optionName, optionType, step, minimum, maximum, redValue) => {
            addOption(displayName, unit, sectionName, optionName, optionType, step, minimum, maximum, redValue);

            // Create name
            const optionNameElement = document.createElement('h1');

            optionNameElement.textContent = `${displayName}`;
            if(unit !== '---'){
                optionNameElement.textContent += ` (${unit})`;
            }

            // Create container
            const div = document.createElement('div');
            div.id = optionName + '-container';
            // div.style.position = 'relative';
            div.appendChild(optionNameElement);

            // Create option

            switch(optionType){
                case "number": {
                        // Insert a cell at the end of the row
                        const input = document.createElement("input");
                        input.setAttribute('type', 'number');
                        input.setAttribute('value', '0');
                        input.setAttribute('step', step);
                        input.id = `${optionName}-input`;
                        input.addEventListener('input', (event) => {
                            const val = event.target.value || 0;
                            const color = getCellColor(val, redValue);
                            event.target.style.backgroundColor = color; 
                            addOptionValue(optionName, val);
                        });
                        input.min = minimum;
                        input.max = maximum;
                        input.style.width = (`${maximum}`.length + 1) + 'em';
                        // Append a text node to the cell
                        div.appendChild(input);
                        input.dispatchEvent(new Event('input', {bubbles:true}));
                    }
                    break;
                case "checkbox": {
                        // Insert a cell at the end of the row
                        const input = document.createElement("input");
                        input.setAttribute('type', 'checkbox');
                        input.id = `${optionName}-input`;
                        input.addEventListener('input', (event) => {
                            const val = event.target.checked;
                            addOptionValue(optionName, val);
                        });
                        // Append a text node to the cell
                        div.appendChild(input);
                        input.dispatchEvent(new Event('input', {bubbles:true}));
                    }
                    break;
                default: 
                    throw new Error("Unknown option type: " + optionType);
                    break;
            }
            // Show table
            const section = document.getElementById(sectionName);
            section.appendChild(div);
        }

        const createTable3D = (displayName, unit, sectionName, mapName, xName, xValues, yName, yValues, cellsMin, cellsMax, cellsRedValue) => {
            /********/addMap3D(displayName, unit, sectionName, mapName, xName, xValues, yName, yValues, cellsMin, cellsMax, cellsRedValue);

            // Create name
            const tableNameElement = document.createElement('h1');
            tableNameElement.textContent = `${displayName} (${unit})`;

            // Create container
            const div = document.createElement('div');
            div.id = mapName + '-container';
            // div.style.position = 'relative';
            div.appendChild(tableNameElement);

            // Create table
            const table = document.createElement('table');
            table.setAttribute('border', 'true');
            table.style.borderCollapse = 'collapse';
            table.style.textAlign = 'center';
            table.id = mapName;
            table.addEventListener("mousedown", (event) => {
                tableToMultiselect = table.id;
            })
            table.addEventListener("mouseup", (event) => {
                tableToMultiselect = undefined;
                if(selectedElements.length >= 1){
                    showSelectionEditorDialog();
                }
            })
            table.addEventListener("mousemove", (event) => {                
                if(tableToMultiselect != table.id){return;}
                const elem = document.elementFromPoint(event.x, event.y);
                if(elem.nodeName !== 'INPUT' || !elem.id.includes(tableToMultiselect)){return;}
                if(selectedElements.includes(elem)){return;}
                selectedElements.push(elem);
                elem.style.backgroundColor = "aqua";
                console.log(selectedElements);
            });
            div.appendChild(table);

            // Create tbody
            const tbody = document.createElement('tbody');
            table.appendChild(tbody)
            tbody.style.position = 'relative';

            // Fill table
            const headerRow = tbody.insertRow();
            const headerCell = headerRow.insertCell();
            const header = document.createElement('p');
            header.textContent = yName;
            header.setAttribute('colspan', 30 + 2);
            headerCell.appendChild(header); 
            for(let yIndex = 0; yIndex < 15; yIndex++) {
                const y = yValues[yIndex];
                const newRow = tbody.insertRow();
                const valueCell = newRow.insertCell();

                const input = document.createElement("input");
                input.setAttribute('type', 'number');
                input.setAttribute('value', y);
                input.setAttribute('step', '0.1');
                input.className = 'no-arrows';
                input.id = `y-${y}-${mapName}`;
                input.addEventListener('change', (event) => {
                    const oldValue = event.target.id.split('-')[1];
                    const newValue = event.target.value;
                    tuneValues[mapName].values[newValue] = tuneValues[mapName].values[oldValue];
                    input.id = `y-${newValue}-${mapName}`;
                    delete tuneValues[mapName].values[oldValue];
                    for (let index = 0; index < tuneValues[mapName].yValues.length; index++) {
                        if(tuneValues[mapName].yValues[index] == oldValue){
                            tuneValues[mapName].yValues[index] = Number(newValue);
                        }
                    }
                    console.log(tuneValues);
                });
                input.style.color = '#ffffff';
                valueCell.appendChild(input);
                
                for (let xIndex = 0; xIndex < 30; xIndex++) {
                    const x = xValues[xIndex];
                    // Insert a cell at the end of the row
                    const newCell = newRow.insertCell();

                    const input = document.createElement("input");
                    input.setAttribute('type', 'number');
                    input.setAttribute('value', '0');
                    input.setAttribute('step', '0.01');
                    input.id = `${x}-${y}-${mapName}`;
                    input.addEventListener('input', (event) => {
                        const val = event.target.value || 0;
                        const color = getCellColor(val, cellsRedValue);
                        event.target.parentNode.style.backgroundColor = color; 
                        addMapValue3D(mapName, y, x, val);
                    });
                    input.min = cellsMin;
                    input.max = cellsMax;
                    // Append a text node to the cell
                    newCell.appendChild(input);
                    input.dispatchEvent(new Event('input', {bubbles:true}));
                }
            }

            const footerRow = tbody.insertRow();
            let footerCell = footerRow.insertCell();
            let footer = document.createElement('p');
            footer.textContent = xName;
            footerCell.appendChild(footer);

            for (let xIndex = 0; xIndex < 30; xIndex++) {
                const x = xValues[xIndex];
                footerCell = footerRow.insertCell();
                // footer = document.createElement('p');
                // footer.textContent = x;
                const input = document.createElement("input");
                input.setAttribute('type', 'number');
                input.setAttribute('value', x);
                input.setAttribute('step', '1');
                input.className = 'no-arrows';
                input.id = `x-${x}-${mapName}`;
                input.addEventListener('change', (event) => {
                    const oldValue = event.target.id.split('-')[1];
                    const newValue = event.target.value;
                    for (const y in tuneValues[mapName].values) {
                        tuneValues[mapName].values[y];
                        tuneValues[mapName].values[y][newValue] = tuneValues[mapName].values[y][oldValue];
                        delete tuneValues[mapName].values[y][oldValue];
                    }
                    input.id = `x-${newValue}-${mapName}`;
                    for (let index = 0; index < tuneValues[mapName].xValues.length; index++) {
                        if(tuneValues[mapName].xValues[index] == oldValue){
                            tuneValues[mapName].xValues[index] == newValue;
                        }
                    }
                    console.log(tuneValues);
                });
                input.style.color = '#ffffff';
                footerCell.appendChild(input); 
            }

            // Show table
            const section = document.getElementById(sectionName);
            section.appendChild(div); 

            // const point = document.createElement('div');
            // point.id = mapName + '-point';
            // point.style.position = 'absolute';
            // // point.style.display = 'none';
            // point.style.width = '5px';
            // point.style.height = '5px';
            // point.style.borderRadius = '50%';
            // point.style.backgroundColor = 'white';
            // section.appendChild(point);
            const canvas = document.createElement('canvas');
            canvas.id = mapName + '-canvas';
            canvas.style.position = 'absolute';
            // point.style.display = 'none';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.backgroundColor = 'rgba(0, 0, 0, 0)';
            // canvas.style.border = "2px solid red";
            // canvas.style.zIndex = "999";
            div.appendChild(canvas);


            // const d0 = document.createElement('div');
            // d0.id = mapName + 'd0';
            // d0.style.position = 'absolute';
            // d0.style.width = '100%';
            // d0.style.height = '5px';
            // d0.style.backgroundColor = 'red';
            // section.appendChild(d0);

            // const d1 = document.createElement('div');
            // d1.id = mapName + 'd1';
            // d1.style.position = 'absolute';
            // d1.style.width = '100%';
            // d1.style.height = '5px';
            // d1.style.backgroundColor = 'blue';
            // section.appendChild(d1);
        }
        
        const createGauge = () => {
            // <canvas class="gauge"></canvas>
            // TODO
        }

        const updateTables = () => {
            for (const [mapName, map] of Object.entries(tuneValues)) {
                if(mapName === 'version'){
                    continue;
                }
                if(mapName === 'options'){
                    document.getElementById('options').innerHTML = '';
                    const options = map;
                    for (const [optionName, option] of Object.entries(options)) {
                        const bkup = tuneValues.options[optionName].value;
                        createOption(option.displayName, option.unit || '---', option.sectionName, optionName, option.optionType, option.step, option.minimum, option.maximum, option.redValue);
                        tuneValues.options[optionName].value = bkup;
                        const input = document.getElementById(`${optionName}-input`);
                        if(option.optionType === 'checkbox'){
                            input.checked = option.value;
                            input.dispatchEvent(new Event('input', {bubbles:true}));
                        }else{
                            input.value = getOptionValue(optionName);
                            input.dispatchEvent(new Event('input', {bubbles:true}));
                        }
                    }
                }else{
                    document.getElementById(map.sectionName).innerHTML = '';
                    const bkup = tuneValues[mapName].values;
                    createTable3D(map.displayName, map.unit, map.sectionName, mapName, map.xName, map.xValues.sort((a, b) => a - b) || defaults.xValues, map.yName, map.yValues.sort((a, b) => b - a) || defaults.yValues, map.cellsMin, map.cellsMax, map.cellsRedValue);
                    tuneValues[mapName].values = bkup;
                    let nextMap = false;
                    for(let yIndex = 0; yIndex < map.yValues.length && !nextMap; yIndex++) {
                        const y = map.yValues[yIndex];
                        // console.log(y, map.yValues);
                        // console.log(map.xValues)
                        for (let xIndex = 0; xIndex < map.xValues.length; xIndex++) {
                            const x = map.xValues[xIndex];
                            const cell = document.getElementById(`${x}-${y}-${mapName}`);
                            if(!cell){
                                nextMap = true;
                                continue;
                            }
                            console.log(cell);
                            cell.value = getMapValue3D(mapName, y, x) || 0;
                            cell.dispatchEvent(new Event('input', {bubbles:true}));
                        }
                    }
                }
            }
        }

        const downloadTune = () => {
            const filename = 'tune.json';
            const tune = JSON.stringify(tuneValues);
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(tune);
            const dlAnchorElem = document.getElementById('downloadAnchorElem');
            dlAnchorElem.setAttribute("href", dataStr);
            dlAnchorElem.setAttribute("download", filename);
            dlAnchorElem.click();
        }

        const loadTune = (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            const reader = new FileReader();
            reader.onload = function(event) {
                const contents = event.target.result;
                tuneValues = JSON.parse(contents);
                if(!SUPPORTED_TUNE_VERSIONS.includes(tuneValues.version )) {
                    console.log("Found old tune: version "  + tuneValues.version);
                    alert("Please, open BeamNG and update the tune. The tune may not be loaded correctly if not updated.");
                }
                updateTables();
            };
            reader.readAsText(file);
        }
        function getCoords(elem) { // crossbrowser version
            let box = elem.getBoundingClientRect();

            let body = document.body;
            let docEl = document.documentElement;

            let scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
            let scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;

            let clientTop = docEl.clientTop || body.clientTop || 0;
            let clientLeft = docEl.clientLeft || body.clientLeft || 0;

            let top  = box.top +  scrollTop - clientTop;
            let left = box.left + scrollLeft - clientLeft;

            return { top, left };
        }

        const init = () => {
            const MIN_LOAD = 0;
            const MAX_LOAD = 100;
            const LOAD_STEP = 10;

            const MIN_RPM = 0;
            const MAX_RPM = 12000;
            const RPM_STEP = 500;

            // Create tables
            createOption('RPM limit', 'RPM', 'options', 'RPM-limit', 'number', 1, 0, 20000, 10000);
            createOption('Knock correction', '---', 'options', 'knock-correction', 'checkbox');
            // createTable('Boost Table', 'PSI', 'boost', 'boost-table', 'RPM', MIN_RPM, MAX_RPM, RPM_STEP, 'Load', MIN_LOAD, MAX_LOAD, LOAD_STEP, 0, 255, 50);
            createTable3D(
                'Ignition Advance Table', 'DegÂº', 'ignition', 'advance-table',
                'RPM', [400, 500, 600, 700, 800, 1000, 1200, 1500, 1800, 2000, 2200, 2400, 2600, 2800, 3100, 3400, 3700, 4000, 4300, 4700, 5100, 5500, 5900, 6200, 6700, 7200, 7700, 8200, 8700, 9200].sort((a, b) => a - b),
                'MAP', [100, 93, 86, 79, 72, 65, 58, 51, 44, 37, 30, 23, 16, 9, 2].sort((a, b) => b - a),
                -90, 90, 40
            );
            createTable3D(
                'Injector Duty Table', '%', 'injector', 'injector-table',
                'RPM', [400, 500, 600, 700, 800, 1000, 1200, 1500, 1800, 2000, 2200, 2400, 2600, 2800, 3100, 3400, 3700, 4000, 4300, 4700, 5100, 5500, 5900, 6200, 6700, 7200, 7700, 8200, 8700, 9200].sort((a, b) => a - b),
                'MAP', [100, 93, 86, 79, 72, 65, 58, 51, 44, 37, 30, 23, 16, 9, 2].sort((a, b) => b - a),
                0, 90, 40
            );
            
            document.getElementById('save-tune').addEventListener('click', () => {downloadTune();})
            document.getElementById('tune-file').addEventListener('change', (event) => {loadTune(event);})

            // https://bernii.github.io/gauge.js/
            let opts = {
                angle: -0.22, // The span of the gauge arc
                lineWidth: 0.17, // The line thickness
                radiusScale: 0.76, // Relative radius
                pointer: {
                    length: 0.6, // // Relative to gauge radius
                    strokeWidth: 0.057, // The thickness
                    color: '#FFFFFF' // Fill color
                },
                limitMax: false,     // If false, max value increases automatically if value > maxValue
                limitMin: false,     // If true, the min value of the gauge will be fixed
                colorStart: '#6FADCF',   // Colors
                colorStop: '#8FC0DA',    // just experiment with them
                strokeColor: '#E0E0E0',  // to see which ones work best for you
                generateGradient: true,
                highDpiSupport: true,     // High resolution support
                
            };
            let target = document.querySelector('canvas#rpm'); // your canvas element
            let gauge = new Gauge(target).setOptions(opts); // create sexy gauge!
            gauge.maxValue = 7500; // set max gauge value
            gauge.setMinValue(0);  // Prefer setter over gauge.minValue = 0
            gauge.animationSpeed = 1; // set animation speed (32 is default value)


            const drawDataPoint = (data) => {
                gauge.set(data['rpm']); // set actual value
                const section = document.getElementById('engine-data');
                section.innerHTML = '';
                Object.keys(data).forEach((key, index) => {
                    const p = document.createElement("p");
                    if(typeof data[key] === "object"){
                        p.innerHTML = `${key}: ${JSON.stringify(data[key])}`;
                    }else{
                        p.innerHTML = `${key}: ${data[key]}`;
                    }
                    section.appendChild(p);
                });
                for (const [mapName, map] of Object.entries(tuneValues)) {
                    // TODO: check if the table uses this data
                    const mapElement = document.getElementById(mapName);
                    
                    if(!mapElement || ['options', 'version'].includes(mapName)){
                        continue;
                    }
                    const canvas = document.getElementById(mapName + '-canvas');
                    const ctx = canvas.getContext('2d');
                    let style = canvas.style;
                    
                    // TODO: optimize
                    const topLeftCell = document.querySelector(`#${mapName} tr:nth-child(2) td:nth-child(2)`);
                    const bottomRightCell = document.querySelector(`#${mapName} tr:nth-last-child(2) td:last-child`);
                    // topLeftCell.style.backgroundColor = 'red';
                    // bottomRightCell.style.backgroundColor = 'blue';
                    // const topLeft = topLeftCell.getBoundingClientRect();
                    // const bottomRight = bottomRightCell.getBoundingClientRect();
                    const topLeft = getCoords(topLeftCell);
                    const bottomRight = getCoords(bottomRightCell);
                    const bottomRightBB = bottomRightCell.getBoundingClientRect();
                    bottomRight.bottom = bottomRight.top + bottomRightBB.height;
                    bottomRight.right = bottomRight.left + bottomRightBB.width;
                    // Resize canvas
                    {
                        style.left = topLeft.left + 'px';
                        style.top = topLeft.top + 'px';
                        style.width = (bottomRight.right - topLeft.left) + 'px';
                        style.height = (bottomRight.bottom - topLeft.top) + 'px';
                        canvas.width = (bottomRight.right - topLeft.left);
                        canvas.height = (bottomRight.bottom - topLeft.top);
                    }
                    
                    // let canvasData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    // Draw marker
                    
                    // rpm : xMax = x : width ==> x = rpm * width / xMax
                    let x = data[map.xName.toLocaleLowerCase()] / map.xMax * canvas.width;
                    let y = (1 - data[map.yName.toLocaleLowerCase()] / map.yMax) * canvas.height;
                    
                    // const index = (x + y * canvas.width) * 4;
                    // canvasData.data[index + 0] = 255;
                    // canvasData.data[index + 1] = 255;
                    // canvasData.data[index + 2] = 255;
                    // canvasData.data[index + 3] = 255;
                    ctx.fillStyle = "#fff";
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillRect(x - 5,  y - 5, 10, 10);

                    // ctx.putImageData(canvasData, 0, 0);
                }
            }
            
            const getData = () => {
                fetch(
                    `http://${window.location.host}/engineData.json`,
                ).then((response) => {
                    return response.json();
                }).then((json) => {
                    setTimeout(() => {
                       
                       try{
                           getData();
                       }catch(e){}
                       drawDataPoint(json);
                    }, 1);
                }).catch((e) => {setTimeout(() => {
                       
                       try{
                           getData();
                       }catch(e){}
                    }, 1);});
            }
            getData();
        }

        document.onload = init();
        
    </script>
</body>
</html>