<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="js/gauge.min.js"></script>
    <script src="js/plotly.js"></script>
    <title>Tables</title>
</head>
<body>
    <style>
        input[type="number"] {
            width: 3em;
            text-align: right;
            border: none;
            background: transparent;
        }
        p {
            margin: 0;
        }
        body {
            background-color: black;
            color: #ccc;
            margin: 0;
            padding: 0;
        }
        table {
            filter: brightness(.5);
            border-spacing: 0;
            border-width: 0;
        }
        canvas {
            pointer-events: none;
        }
        .section#options{
            /* display: flex; */
            flex-wrap: wrap;
            justify-content: center;
        }
        .section#options div{
            display: flex;
            align-items: center;
            margin: 5px;
            border-bottom: 1px solid gray;
        }
        .section#options div > label{
            margin-right: 5px;
            font-size: 1.25em;
        }
        .section {
            display: none;
            overflow-y: scroll;
        }
        .navbar{
            position: absolute;
            top: 0;
            left: 0;
            width: 100px;
            height: 100vh;
            border: 1px solid red;
            display: flex;
            flex-direction: column;
            align-content: start;
        }
        .spacer-75 {
            height: 75px;
        }
        .section-selection {
            height: 50px;
            text-align: center;
            width: 80px;
            margin: 5px;
            display: flex;
            align-items: center;
            border: 1px solid blue;
        }
        .section-selection > p {
            margin: auto;
        }
        div.main {
            margin-left: 100px;
        }
        div#realtime {
            width: 100%;
            border-top: 1px solid red;
            padding: 5px;
        }
        div.general {
            overflow-y: scroll;
            overflow-x: hidden;
        }
        body {
            overflow: hidden;
        }
        input.no-arrows::-webkit-outer-spin-button,
        input.no-arrows::-webkit-inner-spin-button {
            /* display: none; <- Crashes Chrome on hover */
            -webkit-appearance: none;
            margin: 0; /* <-- Apparently some margin are still there even though it's hidden */
        }
        div#engine-data {
            overflow-y: scroll;
            height: 35vh;
        }
        input.no-arrows[type=number] {
            -moz-appearance:textfield; /* Firefox */
        }
        div.selection-editor-group {
            display: flex;
            align-items: center;
            margin: 5px;
            padding: 10px;
            justify-content: center;
        }
        div.selection-editor-group > div {
            margin: 15px;
        }
        div.selection-editor-group > div > label{
            margin-right: 5px;
        }
        div.selection-editor-group > div > input {
            width: 6em;
            color: white;
            border: revert;
        }
        div.selection-editor-group  > button {
            margin: 15px;
            padding: 15px;
        }
        div.tune-name-wrapper {
            margin: 5px 0 0 5px;
        }
        div#engine-data {
            display: flex;
            flex-wrap: wrap;
            width: 100%;
        }
        div#engine-data > div.data-container {
            width: 15%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 5px;
            padding: 10px;
            border: 1px solid gray;
            justify-content: space-evenly;
            position: relative;
        }
        div#engine-data > div.data-container p {
            font-size: 1.25em;
            font-weight: bold;
        }
        img.knock-icon {
            width: 50px;
            height: 50px;
            display: none;
            position: absolute;
            top: 0;
            right: 0;
        }
    </style>
    <div class="navbar" id="navbar">
        <div class="section-selection" id="injector-section-selection"><p>Fuel</p></div>
        <div class="section-selection" id="ignition-section-selection"><p>Ignition</p></div>
        <div class="section-selection" id="boost-section-selection"><p>Boost</p></div>
        <div class="section-selection" id="PWM-section-selection"><p>PWM</p></div>
        <div class="section-selection" id="options-section-selection"><p>Options</p></div>
        <div class="section-selection" id="accelerator-section-selection"><p>Accelerator</p></div>
        <div class="section-selection" id="autoadapt-section-selection"><p>Auto Adapt</p></div>
        <div class="section-selection" id="realtime-section-selection"><p>Real-Time</p></div>
        <div class="section-selection" id="experimental-section-selection"><p>Exp.</p></div>
        <p>Actions</p>
        <!--<input type="file" id="tune-file" />-->
        <button id="load-tune">Load</button>
        <button id="save-tune">Save</button>
        <label for="load-tune-JSON-file">Load from JSON</button>
        <input type="file" id="load-tune-JSON-file" />
    </div>
    <div class="main">
        <div class="general" id="general">
            <div class="tune-name-wrapper"><p>Loaded tune: <b id="tune-name"></b></p></div>
            <div class="section" id="injector"></div>
            <div class="section" id="ignition"></div>
            <div class="section" id="boost"></div>
            <div class="section" id="PWM"></div>
            <div class="section" id="options">
                <h1 style="width: 100%;">Options</h1>
            </div>
            <div class="section" id="accelerator"></div>
            <div class="section" id="autoadapt"></div>
            <div class="section" id="experimental">
                <input type="number" name="RpmOverwrite" id="RpmOverwrite" style="width: 6em;color:white;">
                <label for="RpmOverwrite">RpmOverwrite</label><br>
    
                <input type="number" name="MapOverwrite" id="MapOverwrite" style="width: 6em;color:white;">
                <label for="MapOverwrite">MapOverwrite</label><br>
    
                <input type="checkbox" name="TuningCheatOverwrite" id="TuningCheatOverwrite">
                <label for="TuningCheatOverwrite">TuningCheatOverwrite</label>
                <br>
                <h2>
                    Auto-tuner
                </h2>
                <input type="number" name="fromRPM" id="fromRPM" style="width: 6em;color:white;">
                <label for="fromRPM">From RPM</label><br>
    
                <input type="number" name="toRPM" id="toRPM" style="width: 6em;color:white;">
                <label for="toRPM">To RPM</label><br>
    
                <input type="number" name="fromMAP" id="fromMAP" style="width: 6em;color:white;">
                <label for="fromMAP">From MAP</label><br>
    
                <input type="number" name="toMAP" id="toMAP" style="width: 6em;color:white;">
                <label for="toMAP">To MAP</label><br>
    
                <input type="number" name="targetAFR" id="targetAFR" style="width: 6em;color:white;">
                <label for="targetAFR">Target AFR</label><br>
    
                <button id="autotune">Autotune</button>
                <script type="text/javascript">
                    function sendData() {
                        if(!document.querySelector('#TuningCheatOverwrite').checked){return;}
                        const rpm = document.querySelector('#RpmOverwrite').value;
                        const map = document.querySelector('#MapOverwrite').value;
                        fetch(
                            `http://${window.location.host}/command?RpmOverwrite=${rpm}&MapOverwrite=${map}`,
                        )
                    };
                    document.querySelector('#MapOverwrite').addEventListener("input", sendData);
                    document.querySelector('#RpmOverwrite').addEventListener("input", sendData);
                    document.querySelector('#TuningCheatOverwrite').addEventListener("change", function() {
                        fetch(
                            `http://${window.location.host}/command?TuningCheatOverwrite=${this.checked ? 'true' : 'false'}`,
                        )
                    });
                    async function autoTune(fromRPM, toRPM, fromMAP, toMAP, targetAFR) {
                        for (let x = 0; x < tuneValues['injector-table'].xValues.length; ++x) {
                            const rpm = tuneValues['injector-table'].xValues[x];
                            if(rpm < fromRPM || rpm > toRPM){
                                continue;
                            }
                            for (let y = 0; y < tuneValues['injector-table'].yValues.length; ++y) {
                                const map = tuneValues['injector-table'].yValues[y];
                                if(map < fromMAP || map > toMAP){
                                    continue;
                                }
                                let target_afr = targetAFR;
                                await fetch(
                                    `http://${window.location.host}/command?TuningCheatOverwrite=true&RpmOverwrite=${rpm}&MapOverwrite=${map}`
                                ).then(async () => {
                                    await fetch(`http://${window.location.host}/engineData.json`)
                                        .then((response) => {
                                        return response.json();
                                        })
                                        .then((json) => {
                                            afr = json.afr;
                                            console.log(afr);
                                            const val = document.getElementById(`${rpm}-${map}-injector-table`).value * afr / target_afr;
                                            document.getElementById(`${rpm}-${map}-injector-table`).value = val;
                                            document.getElementById(`${rpm}-${map}-injector-table`).dispatchEvent(new Event('input', {bubbles:true}));
                                        });
                                });
                            }
                        }
    
                        await fetch(
                            `http://${window.location.host}/command?TuningCheatOverwrite=false&RpmOverwrite=0&MapOverwrite=0`
                        )
                    }
                    document.getElementById('autotune').addEventListener('click', () => {
                        autoTune(
                            Number(document.getElementById('fromRPM').value),
                            Number(document.getElementById('toRPM').value),
                            Number(document.getElementById('fromMAP').value),
                            Number(document.getElementById('toMAP').value),
                            Number(document.getElementById('targetAFR').value),
                        );
                    })
    
                </script>
            </div>
        </div>
        <div class="section" id="realtime">
            <p>Real-Time</p>
            <div class="" id="engine-data">
                <div class="data-container">
                    <img src="data:image/png;base64,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" alt="explosion" class="knock-icon">
                    <p>ADV (ºdeg)</p>
                    <p id="ed-ADV"></p>
                </div>
                <div class="data-container"><p>Target Boost (PSI)</p><p id="ed-targetBoostPressure"></p></div>
                <div class="data-container"><p>TPS (%)</p><p id="ed-TPS"></p></div>
                <div class="data-container"><p>IAT (ºC/ºF)</p><p id="ed-IAT"></p></div>
                <div class="data-container"><p>MAF (mg/c)</p><p id="ed-MAF"></p></div>
                <div class="data-container"><p>MAP (kPa)</p><p id="ed-MAP"></p></div>
                <div class="data-container" style="border-width: 3px;"><p>AFR</p><p id="ed-air_fuel_ratio"></p></div>
                <div class="data-container"><p>DC</p><p id="ed-duty"></p></div>
                <div class="data-container"><p>RPM</p><p id="ed-RPM"></p></div>
                <div class="data-container"><p>Fuel Press. (Bar)</p><p id="ed-pressure_bar"></p></div>
            </div>
            <div class="" id="gauges">
                <canvas id="rpm"></canvas>
            </div>
        </div>
    </div>
    <a id="downloadAnchorElem" style="display:none"></a>
    <div id="selection-editor-dialog" style="border: 1px solid red; border-radius: 10px; position: absolute; width: 50%; height: 500px; display: none; left: 50%; top: 50%; transform: translate(-50%, -50%); background: black;">
        <h1 style="text-align: center;">Selection Editor</h1>
        <p style="text-align: center;">Apply a modifier to all selected cells</p>
        <div class="selection-editor-group">
            <div>
                <label for="selection-editor-dialog-modifier">Modifier</label>
                <input type="number" id="selection-editor-dialog-modifier" style="color:white; width: 6em;" />
            </div>
            <div>
                <label for="selection-editor-dialog-modifier-type">Type</label>
                <select id="selection-editor-dialog-modifier-type">
                    <option value="mul">Multiply</option>
                    <option value="div">Divide</option>
                    <option value="sum">Add</option>
                    <option value="sub">Subtract</option>
                    <option value="set">Set</option>
                </select>
            </div>
        </div>
        <div class="selection-editor-group">
            <button id="selection-editor-dialog-apply">Apply</button>
            <button id="selection-editor-dialog-close">Close</button>
        </div>
    </div>
    <script type="text/javascript">
        const openPanels = {};
        const sections = document.getElementsByClassName('section');
        for (const section of sections) {
            section.style.display = 'none';
        }

        const sectionSelections = document.getElementsByClassName('section-selection');
        for (const sectionSelector of sectionSelections) {
            sectionSelector.addEventListener('click', (event) => {
                console.log(event.target.id.split("-")[0]);
                const sect = document.getElementById(event.target.id.split("-")[0]);
                if(!sect){
                    return;
                }
                console.log(sect.style.display );
                if(sect.style.display === 'none'){
                    sect.style.display = 'block';
                    event.target.style.backgroundColor = '#0000ffa7';
                    openPanels[event.target.id.split("-")[0]] = true;
                }else{
                    sect.style.display = 'none';
                    event.target.style.backgroundColor = '#00000000';
                    openPanels[event.target.id.split("-")[0]] = undefined;
                }
                if (openPanels['realtime'] !== undefined){
                    document.getElementById('general').style.height = '60vh';
                }else{
                    document.getElementById('general').style.height = '100vh';
                }
            })
        }

        let tuneValues = {};
        const SUPPORTED_TUNE_VERSIONS = [0.4];
        const defaults = {
            xValues: [400, 500, 600, 700, 800, 1000, 1200, 1500, 1800, 2000, 2200, 2400, 2600, 2800, 3100, 3400, 3700, 4000, 4300, 4700, 5100, 5500, 5900, 6200, 6700, 7200, 7700, 8200, 8700, 9200].sort((a, b) => a - b),
            yValues: [100, 93, 86, 79, 72, 65, 58, 51, 44, 37, 30, 23, 16, 9, 2].sort((a, b) => b - a),
        };
        let tableToMultiselect = undefined;
        let selectedElements = [];

        document.getElementById("selection-editor-dialog-close").addEventListener("click", (event) => {
            document.getElementById("selection-editor-dialog-modifier").value = "";
            document.getElementById("selection-editor-dialog").style.display = "none";
            for (const elem of selectedElements) {
                elem.style.backgroundColor = 'transparent';
            }
            selectedElements = [];
        });
        document.getElementById("selection-editor-dialog-apply").addEventListener("click", (event) => {
            const modifyer = document.getElementById("selection-editor-dialog-modifier").value;
            if(modifyer === ""){
                return;
            }
            const type = document.getElementById("selection-editor-dialog-modifier-type").value;
            const typeFuncitons = {
                mul: (e, mod) => e * mod,
                div: (e, mod) => e / mod,
                sum: (e, mod) => e + mod,
                sub: (e, mod) => e - mod,
                set: (e, mod) => mod,
            };
            if(typeFuncitons[type] === undefined){
                throw new Error("Unknown type: " + type);
            }
            for (const elem of selectedElements) {
                elem.value = Math.round(
                    typeFuncitons[type](
                        Number(elem.value), Number(modifyer)
                    ) * 100
                ) / 100;
                elem.dispatchEvent(new Event('input', {bubbles:true}));
            }
            event.preventDefault();
        });

        const showSelectionEditorDialog = (mapName, title, allCells) => {
            const dialog = document.getElementById("selection-editor-dialog");
            // set title
            dialog.getElementsByTagName("h1")[0].textContent = title;
            // set target to be all cells of map except for axis
            if (allCells) {
                tableToMultiselect = document.getElementById(mapName + "-table");
                const xValues = tuneValues[mapName].xValues;
                const yValues = tuneValues[mapName].yValues;
                
                selectedElements = [];
                for (const x of xValues) {
                    for (const y of yValues) {
                        const cell = document.getElementById(`${x}-${y}-${mapName}`);
                        if (cell) {
                            selectedElements.push(cell);
                        }
                    }
                }
            }
            dialog.style.display = "block";
        }
        
        const addOption = (displayName, unit, sectionName, optionName, optionType, step, minimum, maximum, redValue) => {
            if (tuneValues.options === undefined){
                tuneValues.options = {};
            }
            tuneValues.options[optionName] = {
                value: 0,
                unit,
                displayName,
                sectionName,
                optionType,
                step,
                minimum,
                maximum,
                redValue
            };
        }

        const addOptionValue = (optionName, val) => {
            const value = val;

            if(tuneValues.options[optionName] === undefined){
                throw new Error();
            }

            tuneValues.options[optionName].value = value;
        }

        const getOptionValue = (optionName) => {

            if(tuneValues.options[optionName].value === undefined){
                return undefined;
            }

            return tuneValues.options[optionName].value
        }

        const addMap2D = (displayName, unit, sectionName, mapName, xName, xValues, cellsMin, cellsMax, cellsRedValue) => {
            tuneValues[mapName] = {
                type: "2D",
                values: {},
                displayName,
                unit,
                sectionName,
                xName,
                xValues,
                cellsMin,
                cellsMax,
                cellsRedValue
            }
        }

        const addMapValue2D = (mapName, col, val) => {
            const colIndex = Number(col);
            const value    = Number(val);

            if(tuneValues[mapName] === undefined){
                throw new Error();
            }

            if(tuneValues[mapName].values === undefined){
                tuneValues[mapName].values = {};
            }

            tuneValues[mapName].values[colIndex] = val;
        }

        const getMapValue2D = (mapName, col) => {
            const colIndex = Number(col);

            if(tuneValues[mapName].values === undefined || tuneValues[mapName].type !== "2D"){
                return undefined;
            }

            if(tuneValues[mapName].values[colIndex] === undefined){
                return undefined;
            }

            return tuneValues[mapName].values[colIndex];
        }

        const addMap3D = (displayName, unit, sectionName, mapName, xName, xValues, yName, yValues, cellsMin, cellsMax, cellsRedValue) => {
            tuneValues[mapName] = {
                type: "3D",
                values: {},
                displayName,
                unit,
                sectionName,
                xName,
                xValues: xValues,
                yName,
                yValues: yValues,
                cellsMin,
                cellsMax,
                cellsRedValue
            }
        }

        const addMapValue3D = (mapName, col, row, val) => {
            const colIndex = Number(col);
            const rowIndex = Number(row);
            const value    = Number(val);

            if(tuneValues[mapName] === undefined){
                throw new Error();
            }

            if(tuneValues[mapName].values === undefined){
                tuneValues[mapName].values = {};
            }

            if(tuneValues[mapName].values[colIndex] === undefined){
                tuneValues[mapName].values[colIndex] = {};
            }

            tuneValues[mapName].values[colIndex][rowIndex] = value;
        }

        const getMapValue3D = (mapName, col, row) => {
            const colIndex = Number(col);
            const rowIndex = Number(row);

            if(tuneValues[mapName].values === undefined || tuneValues[mapName].type !== "3D"){
                return undefined;
            }

            if(tuneValues[mapName].values[colIndex] === undefined){
                return undefined;
            }

            return tuneValues[mapName].values[colIndex][rowIndex];
        }
    
        const getCellColor = (value, redValue) => {
            const RED_VALUE = redValue;
            if(value >= RED_VALUE){
                return `hsl(0,100%,50%)`
            }

            const normalizedValue = value / RED_VALUE;
            const hue = ((1 - normalizedValue) * 120).toString(10);
            return `hsl(${hue},100%,50%)`;
        }

        const createOption = (displayName, unit, sectionName, optionName, optionType, step, minimum, maximum, redValue) => {
            addOption(displayName, unit, sectionName, optionName, optionType, step, minimum, maximum, redValue);

            // Create name
            const optionNameElement = document.createElement('label');

            optionNameElement.textContent = `${displayName}`;
            if(unit !== '---'){
                optionNameElement.textContent += ` (${unit})`;
            }

            // Create container
            const div = document.createElement('div');
            div.id = optionName + '-container';
            // div.style.position = 'relative';
            div.appendChild(optionNameElement);

            // Create option

            switch(optionType){
                case "number": {
                        // Insert a cell at the end of the row
                        const input = document.createElement("input");
                        input.setAttribute('type', 'number');
                        input.setAttribute('value', '0');
                        input.setAttribute('step', step);
                        input.id = `${optionName}-input`;
                        input.addEventListener('input', (event) => {
                            const val = event.target.value || 0;
                            const color = getCellColor(val, redValue);
                            event.target.style.backgroundColor = color; 
                            addOptionValue(optionName, val);
                        });
                        input.min = minimum;
                        input.max = maximum;
                        input.style.width = (`${maximum}`.length + 1) + 'em';
                        // Append a text node to the cell
                        div.appendChild(input);
                        input.dispatchEvent(new Event('input', {bubbles:true}));
                    }
                    break;
                case "checkbox": {
                        // Insert a cell at the end of the row
                        const input = document.createElement("input");
                        input.setAttribute('type', 'checkbox');
                        input.id = `${optionName}-input`;
                        input.addEventListener('input', (event) => {
                            const val = event.target.checked;
                            addOptionValue(optionName, val);
                        });
                        // Append a text node to the cell
                        div.appendChild(input);
                        input.dispatchEvent(new Event('input', {bubbles:true}));
                    }
                    break;
                default: 
                    throw new Error("Unknown option type: " + optionType);
                    break;
            }
            // Show table
            const section = document.getElementById(sectionName);
            section.appendChild(div);
        }

        const showQuickActionDialog = (mapName) => {
            showSelectionEditorDialog(mapName, "Quick Action", true);
        }

        const createTable3D = (displayName, unit, sectionName, mapName, xName, xValues, yName, yValues, cellsMin, cellsMax, cellsRedValue) => {
            /********/addMap3D(displayName, unit, sectionName, mapName, xName, xValues, yName, yValues, cellsMin, cellsMax, cellsRedValue);

            // Create name
            const tableNameElement = document.createElement('h1');
            tableNameElement.textContent = `${displayName} (${unit})`;

            // Create container
            const divContainer = document.createElement('div');
            divContainer.id = mapName + '-container';
            // div.style.position = 'relative';
            divContainer.appendChild(tableNameElement);

            // add quick action button
            const quickAction = document.createElement('button');
            quickAction.textContent = "Quick Action";
            quickAction.addEventListener('click', (event) => {
                showQuickActionDialog(mapName);
            });
            divContainer.appendChild(quickAction);

            // add "toggle graph" button
            const toggleGraph = document.createElement('button');
            toggleGraph.textContent = "Toggle Graph";
            toggleGraph.addEventListener('click', (event) => {
                const graph = document.getElementById(mapName + '-graph');
                if(graph.style.display === 'none'){
                    if(document.getElementById(`${mapName}-graph`) !== null){
                        make3Dgraph(mapName, true); // update graph
                    }
                    graph.style.display = 'block';
                }else{
                    graph.style.display = 'none';
                }
            });
            divContainer.appendChild(toggleGraph);

            // Create table
            const table = document.createElement('table');
            table.setAttribute('border', 'true');
            table.style.borderCollapse = 'collapse';
            table.style.textAlign = 'center';
            table.id = mapName;
            table.addEventListener("mousedown", (event) => {
                tableToMultiselect = table.id;
            })
            table.addEventListener("mouseup", (event) => {
                if(selectedElements.length >= 1){
                    showSelectionEditorDialog(tableToMultiselect, "Selection Editor", false);
                }
                tableToMultiselect = undefined;
            })
            table.addEventListener("mousemove", (event) => {                
                if(tableToMultiselect != table.id){return;}
                const elem = document.elementFromPoint(event.x, event.y);
                if(elem.nodeName !== 'INPUT' || !elem.id.includes(tableToMultiselect)){return;}
                if(selectedElements.includes(elem)){return;}
                selectedElements.push(elem);
                elem.style.backgroundColor = "aqua";
                console.log(selectedElements);
            });
            const divTableWrapper = document.createElement('div');
            divTableWrapper.style.width = "fit-content";
            //divTableWrapper.style.position = "relative";
            divTableWrapper.style.height = "fit-content";
            divTableWrapper.appendChild(table);
            divContainer.appendChild(divTableWrapper);

            // Create tbody
            const tbody = document.createElement('tbody');
            table.appendChild(tbody)
            tbody.style.position = 'relative';

            // Fill table
            const headerRow = tbody.insertRow();
            const headerCell = headerRow.insertCell();
            const header = document.createElement('p');
            header.textContent = yName;
            header.setAttribute('colspan', xValues.length + 2);
            headerCell.appendChild(header); 
            for(let yIndex = 0; yIndex < yValues.length; yIndex++) {
                const y = yValues[yIndex];
                const newRow = tbody.insertRow();
                const valueCell = newRow.insertCell();

                const input = document.createElement("input");
                input.setAttribute('type', 'number');
                input.setAttribute('value', y);
                input.setAttribute('step', '0.1');
                input.className = 'no-arrows';
                input.id = `y-${y}-${mapName}`;
                input.addEventListener('change', (event) => {
                    const oldValue = event.target.id.split('-')[1];
                    const newValue = event.target.value;
                    tuneValues[mapName].values[newValue] = tuneValues[mapName].values[oldValue];
                    input.id = `y-${newValue}-${mapName}`;
                    delete tuneValues[mapName].values[oldValue];
                    for (let index = 0; index < tuneValues[mapName].yValues.length; index++) {
                        if(tuneValues[mapName].yValues[index] == oldValue){
                            tuneValues[mapName].yValues[index] = Number(newValue);
                            for(let m = 0; m < tuneValues[mapName].xValues.length; m++){
                                let x = tuneValues[mapName].xValues[m];
                                document.getElementById(`${x}-${oldValue}-${mapName}`).id = `${x}-${newValue}-${mapName}`
                            }
                        }
                    }
                    make3Dgraph(mapName); // update graph
                    console.log(tuneValues);
                });
                input.style.color = '#ffffff';
                valueCell.appendChild(input);
                
                for (let xIndex = 0; xIndex < xValues.length; xIndex++) {
                    const x = xValues[xIndex];
                    // Insert a cell at the end of the row
                    const newCell = newRow.insertCell();

                    const input = document.createElement("input");
                    input.setAttribute('type', 'number');
                    input.setAttribute('value', '0');
                    input.setAttribute('step', '0.01');
                    input.id = `${x}-${y}-${mapName}`;
                    input.addEventListener('input', (event) => {
                        const val = event.target.value || 0;
                        const color = getCellColor(val, cellsRedValue);
                        event.target.parentNode.style.backgroundColor = color;
                        const splitId = input.id.split('-');
                        const xActual = splitId[0];
                        const yActual = splitId[1];
                        addMapValue3D(mapName, yActual, xActual, val);
                        if(document.getElementById(`${mapName}-graph`) !== null){
                            make3Dgraph(mapName); // update graph
                        }
                    });
                    input.min = cellsMin;
                    input.max = cellsMax;
                    // Append a text node to the cell
                    newCell.appendChild(input);
                    input.dispatchEvent(new Event('input', {bubbles:true}));
                }
            }

            const footerRow = tbody.insertRow();
            let footerCell = footerRow.insertCell();
            let footer = document.createElement('p');
            footer.textContent = xName;
            footerCell.appendChild(footer);

            for (let xIndex = 0; xIndex < xValues.length; xIndex++) {
                const x = xValues[xIndex];
                footerCell = footerRow.insertCell();
                // footer = document.createElement('p');
                // footer.textContent = x;
                const input = document.createElement("input");
                input.setAttribute('type', 'number');
                input.setAttribute('value', x);
                input.setAttribute('step', '1');
                input.className = 'no-arrows';
                input.id = `x-${x}-${mapName}`;
                input.addEventListener('change', (event) => {
                    const oldValue = event.target.id.split('-')[1];
                    const newValue = event.target.value;
                    for (const y in tuneValues[mapName].values) {
                        tuneValues[mapName].values[y];
                        tuneValues[mapName].values[y][newValue] = tuneValues[mapName].values[y][oldValue];
                        delete tuneValues[mapName].values[y][oldValue];
                    }
                    input.id = `x-${newValue}-${mapName}`;
                    for (let index = 0; index < tuneValues[mapName].xValues.length; index++) {
                        if(tuneValues[mapName].xValues[index] == oldValue){
                            tuneValues[mapName].xValues[index] = Number(newValue);
                            for(let m = 0; m < tuneValues[mapName].yValues.length; m++){
                                let y = tuneValues[mapName].yValues[m];
                                document.getElementById(`${oldValue}-${y}-${mapName}`).id = `${newValue}-${y}-${mapName}`
                            }
                        }
                    }
                    if(document.getElementById(`${mapName}-graph`) !== null){
                        make3Dgraph(mapName); // update graph
                    }
                    console.log(tuneValues);
                });
                input.style.color = '#ffffff';
                footerCell.appendChild(input); 
            }

            // Show table
            const section = document.getElementById(sectionName);
            section.appendChild(divContainer); 

            // add div with id mapName-graph
            const graph = document.createElement('div');
            graph.id = mapName + '-graph';
            graph.style.display = 'none';
            section.appendChild(graph);

            // const point = document.createElement('div');
            // point.id = mapName + '-point';
            // point.style.position = 'absolute';
            // // point.style.display = 'none';
            // point.style.width = '5px';
            // point.style.height = '5px';
            // point.style.borderRadius = '50%';
            // point.style.backgroundColor = 'white';
            // section.appendChild(point);
            const canvas = document.createElement('canvas');
            divTableWrapper.appendChild(canvas);
            canvas.id = mapName + '-canvas';
            canvas.style.position = 'absolute';
            // point.style.display = 'none';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.backgroundColor = 'rgba(0, 0, 0, 0)';

            // canvas.style.zIndex = "999";

            // const d0 = document.createElement('div');
            // d0.id = mapName + 'd0';
            // d0.style.position = 'absolute';
            // d0.style.width = '100%';
            // d0.style.height = '5px';
            // d0.style.backgroundColor = 'red';
            // section.appendChild(d0);

            // const d1 = document.createElement('div');
            // d1.id = mapName + 'd1';
            // d1.style.position = 'absolute';
            // d1.style.width = '100%';
            // d1.style.height = '5px';
            // d1.style.backgroundColor = 'blue';
            // section.appendChild(d1);
        }
        
        const createTable2D = (displayName, unit, sectionName, mapName, xName, xValues, cellsMin, cellsMax, cellsRedValue) => {
            /********/addMap2D(displayName, unit, sectionName, mapName, xName, xValues, cellsMin, cellsMax, cellsRedValue);

            // Create name
            const tableNameElement = document.createElement('h1');
            tableNameElement.textContent = `${displayName} (${unit})`;

            // Create container
            const div = document.createElement('div');
            div.id = mapName + '-container';
            // div.style.position = 'relative';
            div.appendChild(tableNameElement);

            // Create table
            const table = document.createElement('table');
            table.setAttribute('border', 'true');
            table.style.borderCollapse = 'collapse';
            table.style.textAlign = 'center';
            table.id = mapName;
            table.addEventListener("mousedown", (event) => {
                tableToMultiselect = table.id;
            })
            table.addEventListener("mouseup", (event) => {
                if(selectedElements.length >= 1){
                    showSelectionEditorDialog(tableToMultiselect, "Selection Editor", false);
                }
                tableToMultiselect = undefined;
            })
            table.addEventListener("mousemove", (event) => {                
                if(tableToMultiselect != table.id){return;}
                const elem = document.elementFromPoint(event.x, event.y);
                if(elem.nodeName !== 'INPUT' || !elem.id.includes(tableToMultiselect)){return;}
                if(selectedElements.includes(elem)){return;}
                selectedElements.push(elem);
                elem.style.backgroundColor = "aqua";
                console.log(selectedElements);
            });
            div.appendChild(table);

            // Create tbody
            const tbody = document.createElement('tbody');
            table.appendChild(tbody)
            tbody.style.position = 'relative';

            // Fill table
            const row = tbody.insertRow();
            const headerCell = row.insertCell();
            const header = document.createElement('p');
            header.textContent = unit;
            header.setAttribute('colspan', xValues.length + 2);
            headerCell.appendChild(header);
            for (let xIndex = 0; xIndex < xValues.length; xIndex++) {
                const x = xValues[xIndex];
                // Insert a cell at the end of the row
                const newCell = row.insertCell();

                const input = document.createElement("input");
                input.setAttribute('type', 'number');
                input.setAttribute('value', '0');
                input.setAttribute('step', '0.01');
                input.id = `${x}-${mapName}`;
                input.addEventListener('input', (event) => {
                    const val = event.target.value || 0;
                    const color = getCellColor(val, cellsRedValue);
                    event.target.parentNode.style.backgroundColor = color;
                    const splitId = input.id.split('-');
                    const xActual = splitId[0];
                    addMapValue2D(mapName, xActual, val);
                });
                input.min = cellsMin;
                input.max = cellsMax;
                // Append a text node to the cell
                newCell.appendChild(input);
                input.dispatchEvent(new Event('input', {bubbles:true}));
            }

            const footerRow = tbody.insertRow();
            let footerCell = footerRow.insertCell();
            let footer = document.createElement('p');
            footer.textContent = xName;
            footerCell.appendChild(footer);

            for (let xIndex = 0; xIndex < xValues.length; xIndex++) {
                const x = xValues[xIndex];
                footerCell = footerRow.insertCell();
                // footer = document.createElement('p');
                // footer.textContent = x;
                const input = document.createElement("input");
                input.setAttribute('type', 'number');
                input.setAttribute('value', x);
                input.setAttribute('step', '1');
                input.className = 'no-arrows';
                input.id = `x-${x}-${mapName}`;
                input.addEventListener('change', (event) => {
                    const oldValue = event.target.id.split('-')[1];
                    const newValue = event.target.value;
                    input.id = `x-${newValue}-${mapName}`;
                    for (let index = 0; index < tuneValues[mapName].xValues.length; index++) {
                        if(tuneValues[mapName].xValues[index] == oldValue){
                            tuneValues[mapName].xValues[index] = Number(newValue);
                        }
                    }
                });
                input.style.color = '#ffffff';
                footerCell.appendChild(input); 
            }

            // Show table
            const section = document.getElementById(sectionName);
            section.appendChild(div); 

            // const point = document.createElement('div');
            // point.id = mapName + '-point';
            // point.style.position = 'absolute';
            // // point.style.display = 'none';
            // point.style.width = '5px';
            // point.style.height = '5px';
            // point.style.borderRadius = '50%';
            // point.style.backgroundColor = 'white';
            // section.appendChild(point);
            const canvas = document.createElement('canvas');
            canvas.id = mapName + '-canvas';
            canvas.style.position = 'absolute';
            // point.style.display = 'none';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.backgroundColor = 'rgba(0, 0, 0, 0)';
            // canvas.style.border = "2px solid red";
            // canvas.style.zIndex = "999";
            div.appendChild(canvas);


            // const d0 = document.createElement('div');
            // d0.id = mapName + 'd0';
            // d0.style.position = 'absolute';
            // d0.style.width = '100%';
            // d0.style.height = '5px';
            // d0.style.backgroundColor = 'red';
            // section.appendChild(d0);

            // const d1 = document.createElement('div');
            // d1.id = mapName + 'd1';
            // d1.style.position = 'absolute';
            // d1.style.width = '100%';
            // d1.style.height = '5px';
            // d1.style.backgroundColor = 'blue';
            // section.appendChild(d1);
        }

        const createGauge = () => {
            // <canvas class="gauge"></canvas>
            // TODO
        }

        const updateTables = () => {
            for (const [mapName, map] of Object.entries(tuneValues)) {
                if(mapName === 'version'){
                    continue;
                }
                if(mapName === 'options'){
                    document.getElementById('options').innerHTML = '';
                }else{
                    document.getElementById(map.sectionName).innerHTML = '';
                }
            }

            for (const [mapName, map] of Object.entries(tuneValues)) {
                if(mapName === 'version'){
                    continue;
                }
                if(mapName === 'options'){
                    const options = map;
                    for (const [optionName, option] of Object.entries(options)) {
                        const bkup = tuneValues.options[optionName].value;
                        createOption(option.displayName, option.unit || '---', option.sectionName, optionName, option.optionType, option.step, option.minimum, option.maximum, option.redValue);
                        tuneValues.options[optionName].value = bkup;
                        const input = document.getElementById(`${optionName}-input`);
                        if(option.optionType === 'checkbox'){
                            input.checked = option.value;
                            input.dispatchEvent(new Event('input', {bubbles:true}));
                        }else{
                            input.value = getOptionValue(optionName);
                            input.dispatchEvent(new Event('input', {bubbles:true}));
                        }
                    }
                }else if(map != undefined && map.type === '3D'){
                    const bkup = tuneValues[mapName].values;
                    createTable3D(map.displayName, map.unit, map.sectionName, mapName, map.xName, map.xValues.sort((a, b) => a - b) || defaults.xValues, map.yName, map.yValues.sort((a, b) => b - a) || defaults.yValues, map.cellsMin, map.cellsMax, map.cellsRedValue);
                    tuneValues[mapName].values = bkup;
                    let nextMap = false;
                    for(let yIndex = 0; yIndex < map.yValues.length && !nextMap; yIndex++) {
                        const y = map.yValues[yIndex];
                        // console.log(y, map.yValues);
                        // console.log(map.xValues)
                        for (let xIndex = 0; xIndex < map.xValues.length; xIndex++) {
                            const x = map.xValues[xIndex];
                            const cell = document.getElementById(`${x}-${y}-${mapName}`);
                            if(!cell){
                                nextMap = true;
                                continue;
                            }
                            // console.log(cell);
                            cell.value = getMapValue3D(mapName, y, x) || 0;
                            cell.dispatchEvent(new Event('input', {bubbles:true}));
                        }
                    }
                }else if(map != undefined && map.type === '2D'){
                    const bkup = tuneValues[mapName].values;
                    createTable2D(map.displayName, map.unit, map.sectionName, mapName, map.xName, map.xValues.sort((a, b) => a - b) || defaults.xValues, map.cellsMin, map.cellsMax, map.cellsRedValue);
                    tuneValues[mapName].values = bkup;
                    for (let xIndex = 0; xIndex < map.xValues.length; xIndex++) {
                        const x = map.xValues[xIndex];
                        const cell = document.getElementById(`${x}-${mapName}`);
                        cell.value = getMapValue2D(mapName, x) || 0;
                        cell.dispatchEvent(new Event('input', {bubbles:true}));
                    }
                }
            }
        }

        const saveTune = () => {
            console.log("seding: " + JSON.stringify(tuneValues))
            fetch(`http://${window.location.host}/saveTune`, {
                method: 'POST',
                headers: {
                    "Content-type": "application/json; charset=UTF-8"
                },
                body: JSON.stringify(tuneValues)
            }).then(res => res.json())
                .then(res => console.log(res));
        }

        const loadTune = (tuneJson, called) => {
            console.log("load tune", tuneJson, called);
            if(tuneJson === undefined && called === undefined) {
                document.getElementById('tune-name').textContent = "Loading...";
                fetch(`http://${window.location.host}/getTune`)
                    .then(txt => txt.json())
                    .then(json => loadTune(json, true));    
            }
            const res = tuneJson;
            if(res === undefined || res.tune === undefined || res.tuneFileKey === undefined){
                return;
            }

            tuneValues = res.tune;

            document.getElementById('tune-name').textContent = res.tuneFileKey;

            if(!SUPPORTED_TUNE_VERSIONS.includes(tuneValues.version )) {
                console.log("Found old tune: version "  + tuneValues.version);
                alert("Please, open BeamNG and update the tune. The tune may not be loaded correctly if not updated.");
            }
            updateTables();
        }

        const loadTuneFromJSONFile = (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            const reader = new FileReader();
            reader.onload = function(event) {
                const contents = event.target.result;
                tuneValues = JSON.parse(contents);
                if(!SUPPORTED_TUNE_VERSIONS.includes(tuneValues.version )) {
                    console.log("Found old tune: version "  + tuneValues.version);
                    alert("Please, open BeamNG and update the tune. The tune may not be loaded correctly if not updated.");
                }
                updateTables();
            };
            reader.readAsText(file);
        }

        function getCoords(elem) { // crossbrowser version
            let box = elem.getBoundingClientRect();

            let body = document.body;
            let docEl = document.documentElement;

            let scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
            let scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;

            let clientTop = docEl.clientTop || body.clientTop || 0;
            let clientLeft = docEl.clientLeft || body.clientLeft || 0;

            let top  = box.top +  scrollTop - clientTop;
            let left = box.left + scrollLeft - clientLeft;

            return { top, left, width: box.width, height: box.height };
        }

        const make3Dgraph = (mapName, create) => {
            if(tuneValues[mapName] === undefined){
                return;
            }
            if(tuneValues[mapName].type !== "3D"){
                return;
            }
            if(document.getElementById(mapName + '-graph') === null){
                return;
            }
            if(document.getElementById(mapName + '-graph').style.display === 'none' && !create){
                return;
            }
            const title = tuneValues[mapName].displayName;
            
            const xValues = tuneValues[mapName].xValues.sort((a, b) => a - b);
            const xName = tuneValues[mapName].xName;
            
            const yValues = tuneValues[mapName].yValues.sort((a, b) => a - b);;
            const yName = tuneValues[mapName].yName;

            const unit = tuneValues[mapName].unit;

            const data = tuneValues[mapName].values;

            // function updateValue(x, y, value) {
            //     data[0]['y'][0] = value; 
            //     Plotly.redraw('PlotlyTest');
            // }
            const vertices = [];
            // sort data by x and y
            // data = Object.keys(data).sort().reduce((acc, key) => {
            //     acc[key] = data[key];
            //     return acc;
            // }, {});
            

            // for each data point in the data object create a vertex for the shape
            let i = 0;
            for (let y in data) {
                let j = 0;
                vertices[i] = [];
                for (let x in data[y]) {
                    vertices[i][j] = data[y][x];
                    j += 1;
                }
                i += 1;
            }
            var plot = [{
                z: vertices,
                type: 'surface',
                contours: {
                    x: { show: true },
                    y: { show: true },
                    z: { show: true }
                },
            }];

            var layout = {
                plot_bgcolor:"black",
                paper_bgcolor:"#FFF3",
                title: title,
                autosize: false,
                width: 500,
                height: 500,
                margin: {
                    l: 30,
                    r: 30,
                    b: 30,
                    t: 30,
                },
                font: {
                    family: 'Arial, sans-serif',
                    size: 12,
                    color: '#fff'
                },
                scene: {
                    xaxis: {
                        ticktext: xValues,
                        tickvals: xValues.map((_, i) => i),
                        title: xName,
                    },
                    yaxis: {
                        ticktext: yValues,
                        tickvals: yValues.map((_, i) => i),
                        title: yName,
                    },
                    zaxis: { title: unit },
                }
            };

            Plotly.react(mapName + '-graph', plot, layout);
        }

        const init = () => {
            const MIN_LOAD = 0;
            const MAX_LOAD = 100;
            const LOAD_STEP = 10;

            const MIN_RPM = 0;
            const MAX_RPM = 12000;
            const RPM_STEP = 500;

            // Create tables
            createOption('RPM limit', 'RPM', 'options', 'RPM-limit', 'number', 1, 0, 20000, 10000);
            createOption('Drive-by-Wire Idle Throttle Opening', '%', 'options', 'dbw-idle-throttle', 'number', 0.1, 0, 25, 10);
            createOption('Knock correction', '---', 'options', 'knock-correction', 'checkbox');
            
            // createTable('Boost Table', 'PSI', 'boost', 'boost-table', 'RPM', MIN_RPM, MAX_RPM, RPM_STEP, 'Load', MIN_LOAD, MAX_LOAD, LOAD_STEP, 0, 255, 50);
            createTable3D(
                'Boost Table', 'PSI', 'boost', 'boost-table',
                'RPM', [600, 1200, 1800, 2400, 2800, 3400, 4000, 4700, 5500, 6200, 7200, 8200].sort((a, b) => a - b),
                'TPS', [100, 90, 75, 60, 45, 20, 10, 0].sort((a, b) => b - a),
                0, 255, 40
            );
            createTable3D(
                'Ignition Advance Table', 'Degº', 'ignition', 'advance-table',
                'RPM', [400, 500, 600, 700, 800, 1000, 1200, 1500, 1800, 2000, 2200, 2400, 2600, 2800, 3100, 3400, 3700, 4000, 4300, 4700, 5100, 5500, 5900, 6200, 6700, 7200, 7700, 8200, 8700, 9200].sort((a, b) => a - b),
                'MAP', [100, 93, 86, 79, 72, 65, 58, 51, 44, 37, 30, 23, 16, 9, 2].sort((a, b) => b - a),
                -90, 90, 40
            );
            createTable3D(
                'Injector Duty Table', '%', 'injector', 'injector-table',
                'RPM', [400, 500, 600, 700, 800, 1000, 1200, 1500, 1800, 2000, 2200, 2400, 2600, 2800, 3100, 3400, 3700, 4000, 4300, 4700, 5100, 5500, 5900, 6200, 6700, 7200, 7700, 8200, 8700, 9200].sort((a, b) => a - b),
                'MAP', [100, 93, 86, 79, 72, 65, 58, 51, 44, 37, 30, 23, 16, 9, 2].sort((a, b) => b - a),
                0, 90, 40
            );

            createTable2D(
                'Variable Length Runners Table', '%', 'PWM', 'vlr-table',
                'RPM', [400, 500, 600, 700, 800, 1000, 1200, 1500, 1800, 2000, 2200, 2400, 2600, 2800, 3100, 3400, 3700, 4000, 4300, 4700, 5100, 5500, 5900, 6200, 6700, 7200, 7700, 8200, 8700, 9200].sort((a, b) => a - b),
                0, 100, 100
            )
            
            // add accelerator position table
            createTable3D(
                'Accelerator Position', '%', 'PWM', 'accelerator-position-table',
                'RPM', [400, 500, 600, 700, 800, 1000, 1200, 1500, 1800, 2000, 2200, 2400, 2600, 2800, 3100, 3400, 3700, 4000, 4300, 4700, 5100, 5500, 5900, 6200, 6700, 7200, 7700, 8200, 8700, 9200].sort((a, b) => a - b),
                'TPS', [100, 93, 86, 79, 72, 65, 58, 51, 44, 37, 30, 23, 16, 9, 2].sort((a, b) => b - a),
                0, 100, 100
            );

            // add after start enrichment 2d table
            createTable2D(
                'After Start Enrichment', '%', 'injector', 'after-start-enrichment-table',
                'Coolant ºC', [-20, -10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 140],
                1, 3, 2
            );

            //  Add IAT temperature compensation table
            createTable2D(
                'IAT Temperature Compensation', 'ºC', 'injector', 'iat-injection-compensation-table',
                'IAT ºC', [-20, -10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 140],
                0.5, 1.5, 1
            );

            // add iat timing compensation 
            createTable2D(
                'IAT Timing Compensation', 'ºC', 'ignition', 'iat-timing-compensation-table',
                'IAT ºC', [-20, -10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 140],
                -15, 15, 5
            );

            // add boost cut option
            createOption('Boost Cut', 'PSI', 'options', 'boost-cut', 'number', 0, 0, 255, 30);

            // add knock sensor sensitivity option
            createOption('Knock Sensor Sensitivity', '%', 'options', 'knock-sensitivity', 'number', 0, 0, 100, 10);

            // add knock autoadaptation option
            // createOption('Knock Autoadaptation Speed', '%', 'options', 'knock-autoadaptation', 'number', 0, 0, 100, 10);

            // add knock detected maximum retard option
            createOption('Knock Max Retard', 'º', 'options', 'knock-max-retard', 'number', 0, 0, 40, 10);

            // add knock autoadaptation 3d table based on MAP and RPM
            createTable3D(
                'Knock Autoadaptation', '%', 'autoadapt', 'knock-autoadaptation-table',
                'RPM', [600, 1200, 1800, 2400, 2800, 3400, 4000, 4700, 5500, 6200, 7200, 8200].sort((a, b) => a - b),
                'MAP', [100, 90, 75, 60, 45, 20, 10, 0].sort((a, b) => b - a),
                0, 100, 100
            );

            // add max timing 2D map with knock count as x axis
            createTable2D(
                'Max Timing Retard', 'º', 'autoadapt', 'max-knk-timing-retard-table',
                'Knock Count', [0, 5, 10, 20, 40, 80, 100, 150, 200, 300, 400],
                0, 30, 12
            );

            document.getElementById('save-tune').addEventListener('click', saveTune);
            document.getElementById('load-tune').addEventListener('click', (e) => loadTune());
            document.getElementById('load-tune-JSON-file').addEventListener('change', loadTuneFromJSONFile);
            loadTune();
            // https://bernii.github.io/gauge.js/
            let opts = {
                angle: -0.22, // The span of the gauge arc
                lineWidth: 0.17, // The line thickness
                radiusScale: 0.76, // Relative radius
                pointer: {
                    length: 0.6, // // Relative to gauge radius
                    strokeWidth: 0.057, // The thickness
                    color: '#FFFFFF' // Fill color
                },
                limitMax: false,     // If false, max value increases automatically if value > maxValue
                limitMin: false,     // If true, the min value of the gauge will be fixed
                colorStart: '#6FADCF',   // Colors
                colorStop: '#8FC0DA',    // just experiment with them
                strokeColor: '#E0E0E0',  // to see which ones work best for you
                generateGradient: true,
                highDpiSupport: true,     // High resolution support
                
            };
            let target = document.querySelector('canvas#rpm'); // your canvas element
            let gauge = new Gauge(target).setOptions(opts); // create sexy gauge!
            gauge.maxValue = 7500; // set max gauge value
            gauge.setMinValue(0);  // Prefer setter over gauge.minValue = 0
            gauge.animationSpeed = 1; // set animation speed (32 is default value)

            const printData = (toPrint, fullData) => {
                const section = document.getElementById('engine-data');
                Object.keys(toPrint).forEach((key, index) => {
                    if(typeof toPrint[key] === "object"){
                        printData(toPrint[key], fullData);
                    }else{
                        const p = section.querySelector('#ed-' + key);
                        if(!p && key !== 'knockSensor'){
                            return;
                        }
                        let value = Math.round(toPrint[key] * 100, 2) / 100;
                        if(!isFinite(value)){
                            value = '---';
                        }
                        if(key === 'air_fuel_ratio'){
                            const parent = p.parentNode;
                            if(value > 15.5){
                                parent.style.borderColor = 'red';
                                parent.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
                            }else if(value < 13){
                                parent.style.borderColor = 'green';
                                parent.style.backgroundColor = 'rgba(0, 255, 0, 0.5)';
                            }else{
                                parent.style.borderColor = 'yellow';
                                parent.style.backgroundColor = 'rgba(255, 255, 0, 0.5)';
                            }
                        }else if(key === "duty"){
                            const parent = p.parentNode;
                            if(value > 0.85){
                                parent.style.borderColor = 'red';
                                parent.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
                            } else if(value > 0.75){
                                parent.style.borderColor = 'yellow';
                                parent.style.backgroundColor = 'rgba(255, 255, 0, 0.5)';
                            }else{
                                parent.style.borderColor = 'green';
                                parent.style.backgroundColor = 'rgba(0, 255, 0, 0.5)';
                            }
                        }else if (key === "RPM") {
                            value = Math.round(value);
                            if (value > tuneValues.options['RPM-limit'].value - 100) {
                                const parent = p.parentNode;
                                parent.style.borderColor = 'red';
                                parent.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
                            } else if (value > tuneValues.options['RPM-limit'].value - 500) {
                                const parent = p.parentNode;
                                parent.style.borderColor = 'yellow';
                                parent.style.backgroundColor = 'rgba(255, 255, 0, 0.5)';
                            } else {
                                const parent = p.parentNode;
                                parent.style.borderColor = 'gray';
                                parent.style.backgroundColor = 'transparent';
                            }
                        }else if (key === "targetBoostPressure") {
                            // convert from pa to psi
                            value = Math.round(value * 0.00014503773773020923 * 100) / 100;
                        }else if (key === "IAT") {
                            // convert from kelvin to celsius
                            value = Math.round(value - 273.15);
                            // append measurement in farhenheit
                            value += 'ºC / ' + Math.round(value * 9 / 5 + 32) + 'ºF';

                        }else if (key === "knockSensor") {
                            const adv_parent = document.getElementById('ed-ADV').parentNode;
                            const knk_icon = document.querySelector('img.knock-icon');
                            if(value){
                                adv_parent.style.borderColor = 'red';
                                adv_parent.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
                                knk_icon.style.display = 'block';
                                setTimeout(() => {
                                    knk_icon.style.display = 'none';
                                }, 100);

                            } else {
                                adv_parent.style.borderColor = 'gray';
                                adv_parent.style.backgroundColor = 'transparent';
                                knk_icon.style.display = 'none';
                            }
                        }else if (key === "pressure_bar"){
                            const target_delta = 3 + fullData['manifold']['MAP'] / 100 - 1; //[[bar]]
                            if (value < target_delta * 0.95) {
                                const parent = p.parentNode;
                                parent.style.borderColor = 'red'; 
                                parent.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
                            }else {
                                const parent = p.parentNode;
                                parent.style.borderColor = 'gray';
                                parent.style.backgroundColor = 'transparent';
                            }
                        }
                        if(p){
                            p.innerHTML = value;
                        }
                    }
                });
            };

            // function to position on x axis
            const getXPosition = (value, axisValues) => {
                // x axis is xValues, find the index of x in xValues by looking for the left and right values
                if(value < axisValues[0]){
                    const position = value / axisValues[0];
                    return {
                        prev: 0,
                        next: 0,
                        position
                    };
                }
                if (value > axisValues[axisValues.length - 1]) {
                    const position = value / axisValues[axisValues.length - 1];
                    return {
                        prev: axisValues.length - 1,
                        next: axisValues.length - 1,
                        position
                    };
                }
                let prev = 0;
                let next = 0;
                for (let index = 0; index < axisValues.length; index++) {
                    const element = axisValues[index];
                    if(element < value){
                        prev = index;
                    }
                    if(element >= value){
                        next = index;
                        break;
                    }
                }
                const prevValue = axisValues[prev];
                const nextValue = axisValues[next];
                // calc posisition of value between prevValue and nextValue
                const position = (value - prevValue) / (nextValue - prevValue);

                return {
                    prev,
                    next,
                    position
                };
            }

            const getMapAxisValues = (data) => {
                return {
                    "coolant ºc": data.coolantC,
                    "rpm": data.RPM,
                    "tps": data.manifold.throttle.TPS * 100,
                    "map": data.manifold.MAP,
                    "iat ºc": data.manifold.IAT,
                }   
            }

            const drawDataPoint = (data) => {
                const mapAxisValues = getMapAxisValues(data);
                printData(data, data); // print realtime panel

                for (const [mapName, map] of Object.entries(tuneValues)) {
                    const mapElement = document.getElementById(mapName);
                    if(!mapElement || ['options', 'version'].includes(mapName)){
                        continue;
                    }
                    if(document.getElementById(map.sectionName).style.display === 'none'){
                        continue;
                    }
                    if(map.type !== '3D' || map.yName === undefined || map.xName === undefined || map.yValues === undefined || map.xValues === undefined || map.yValues.length === 0 || map.xValues.length === 0){
                        continue;
                    }

                    const canvas = document.getElementById(mapName + '-canvas');
                    const ctx = canvas.getContext('2d');
                    let style = canvas.style;
                    
                    // TODO: optimize
                    const topLeftCell = document.querySelector(`#${mapName} tr:nth-child(2) td:nth-child(2)`);
                    const bottomRightCell = document.querySelector(`#${mapName} tr:nth-last-child(2) td:last-child`);
                    // topLeftCell.style.backgroundColor = 'red';
                    // bottomRightCell.style.backgroundColor = 'blue';
                    // const topLeft = topLeftCell.getBoundingClientRect();
                    // const bottomRight = bottomRightCell.getBoundingClientRect();
                    const topLeft = getCoords(topLeftCell);
                    const bottomRight = getCoords(bottomRightCell);
                    const bottomRightBB = bottomRightCell.getBoundingClientRect();
                    bottomRight.bottom = bottomRight.top + bottomRightBB.height;
                    bottomRight.right = bottomRight.left + bottomRightBB.width;
                    // Resize canvas
                    {
                        style.left = topLeft.left + 'px';
                        style.top = topLeft.top + 'px';
                        style.width = (bottomRight.right - topLeft.left) + 'px';
                        style.height = (bottomRight.bottom - topLeft.top) + 'px';
                        canvas.width = (bottomRight.right - topLeft.left);
                        canvas.height = (bottomRight.bottom - topLeft.top);
                    }
                    
                    //let canvasData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    // Draw marker
                    const x = mapAxisValues[map.xName.toLowerCase()];
                    const xRes = getXPosition(x, map.xValues);
                    const xLeftValue = map.xValues[xRes.prev];
                    const xRightValue = map.xValues[xRes.next];
                    // xposition is the position of x between the center of the elements of left and right
                    // bin are all of same width which is the width of the canvas divided by the number of bins
                    const xBinsWidth = canvas.width / map.xValues.length;
                    const xBinLeftCenter = xRes.prev * xBinsWidth + (xRes.prev > 0 ? xBinsWidth / 2 : 0);
                    const xBinRightCenter = xRes.next * xBinsWidth + xBinsWidth / 2;
                    const xPosition = xBinLeftCenter + (xBinRightCenter - xBinLeftCenter) * xRes.position;

                    const y = mapAxisValues[map.yName.toLowerCase()];
                    // sort y values in ascending order
                    const sortedYValues = [...map.yValues].sort((a, b) => a - b);
                    const yRes = getXPosition(y, sortedYValues);
                    const yBottomValue = sortedYValues[yRes.prev];
                    const yTopValue = sortedYValues[yRes.next];

                    // yPosition is the position of y between the center of the elements of bottom and top
                    // bin are all of same width which is the width of the canvas divided by the number of bins
                    const yBinsHeight = canvas.height / sortedYValues.length;
                    const yBinBottomCenter = yRes.prev * yBinsHeight + yBinsHeight / 2;
                    const yBinTopCenter = yRes.next * yBinsHeight + yBinsHeight / 2;
                    const yPosition = canvas.height - (yBinBottomCenter + (yBinTopCenter - yBinBottomCenter) * yRes.position);
                    //console.log(yBinBottomCenter, yBinTopCenter, yPosition);
                    
                    // draw vertival line from bottom to yPosition
                    ctx.beginPath();
                    ctx.moveTo(xPosition, canvas.height);
                    ctx.lineTo(xPosition, yPosition);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(255, 255, 255)';
                    ctx.stroke();

                    // draw horizontal line from left to xPosition
                    ctx.beginPath();
                    ctx.moveTo(0, yPosition);
                    ctx.lineTo(xPosition, yPosition);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(255, 255, 255)';
                    ctx.stroke();

                    // draw point at xPosition, yPosition
                    ctx.beginPath();
                    ctx.arc(xPosition, yPosition, 5, 0, 2 * Math.PI, false);
                    ctx.fillStyle = 'green';
                    ctx.fill();
                    ctx.lineWidth = 5;
                    ctx.strokeStyle = '#003300';
                    ctx.stroke();
                }
            }
            
            const getData = () => {
                fetch(
                    `http://${window.location.host}/engineData.json`,
                ).then((response) => {
                    return response.json();
                }).then((json) => {
                    setTimeout(() => {
                       
                       try{
                           getData();
                       }catch(e){}
                       drawDataPoint(json);
                    }, 1);
                }).catch((e) => {setTimeout(() => {
                       
                       try{
                           getData();
                       }catch(e){}
                    }, 1);});
            };
            getData();
        }

        document.onload = init();
        
    </script>
</body>
</html>